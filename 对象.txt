	instanceof检查一个对象是否属于某个类
	属性判断：
		in判断私有属性+公有属性
		hasOwnProperty：查看是否是对象上的私有属性
		



	对象有两部分组成:
		特点
		1、封装：低耦合高内聚
		2、继承：子类继承父类的属性和方法
		3、多态：多种形态，包括重载和重写
			重载js中相同函数名，后面会把前面的覆盖掉，所以js不存在重载；但js中有类似重载的思想，计传不同的参数实现不同的效果
			重写：子类可以重写父类的属性和方法
	


	不同模块之间的调用：模块名.属性名
	同・                                                                                                                                                                                                                                                          一个模块之间的相互调用：this.属性名或者this.方法名   






	面向对象的编程->以对象数据为导向的编程
	用编程的语言来描述书屋的方式就是基于对象的概念
	单例模式
	
	
	

	对象是一种非常抽象的概念

	对象：泛指，js中万物皆对象

	类：对象中具体的事物中的一个细分

	实例：类中具体的一个实例




	关键要理解好对象->多种数据类型的复合载体
	对象类型和值类型的区别是什么？―>本质：我们看待事物的角度不一样





	单例模式：效率低，冗余高，需要一个一个新建对象的，大大降低了我们页面开发的效率
		把描述同一个事物的属性和方法存在相同命名空间里进行分组，以防止因为某事物的属性相同产生的冲突问题
		其实就是一个对象
		对象类型的数据，浏览器会为其开辟一个堆内存，然后将其属性和值存储在这个空间里，给这个空间起一个特定的名字
		单例模式返回的是一个对象（单个的实例），好处1、可以实现分组 2、防止冲突3、各个模块之间可以相互调用




	在工作中协同开发就非常方便，还常常通过类库实现模块化开发（require.js/sea.js）



	闭包可以实现模块化开发，但是不能实现各个模块之间的相互调用





	工厂模式：没法解决产品差异化，没法解决实例识别的问题。工厂模式返回的都是一个对象
		函数的封装（将页面上实现相同功能的js代码封装在一个函数里，在函数里每次都会新建对象，并且把对象返回）
	




	构造模式：解决实例识别的问题，通过创建自定义类，创建类的实例，只要知道这个对象是属于哪个类的，也就是解决实例识别的问题
	

		构造函数首字符大写


		new+函数名
		通过关键字new关键字执行函数Shift，那这个函数Shift就是一个构造函数（类）

		1、隐式的创建一个对象，运行完之后把这个对象返回
		2、以实例为执行主体运行这个函数->构造函数里的this指的就是实例
		3、不需要写return，会把对象自动返回
		new Shift（“年”）匿名的实例


	构造函数细节：
		1、函数体里的this.xxx，表示给实例添加了属性xxx
		2、构造函数里定义的私有变量和实例没有关系，方法运行完之后，私有变量就销毁了
		3、通过instanceof来检测返回的实例属于哪个类
		4、构造函数里的this指的是实例
		5、如果手动写返回值，则有可能会对实例造成影响
			如果返回的基本数据类型的，则对实例没有影响
			如果返回的是引用数据类型的值，则对实例有影响，会把构造函数的默认值覆盖，因为构造函数的默认返回值是
		6、通过this.xxx设置的属性都是实力的私有属性（hasOwnProper可以检测属性是不是私有的
			hasWonProper是私有的就是ture
		7、in只能判断这个属性是不是被包含在这个实例里面


	可以通过instanceof来检测下返回这个 实例是否属于Shift类的





	prototype属性里面是存储的公有的属性和方法
	每个函数都有一个prototype属性，指向浏览器默认开辟的一个堆内存，prototype只有在构造函数这边才有意思，在普通函数那边是没有意义的
	prototype上面天生自带一个constructor属性，指向构造函数



	每一个对象（实例，prototype）天生自带一个属性(_ _proto_ _)，指向所属类的原型




	原型链查找机制：
		1、对象.属性   先在自己的私有空间内找，如果找到就用私有空间的属性
		2、如果找不到，通过_ _proto_ _继续往该实例所属类的原型上找；如果找到，他是一个公有的属性；
		3、找不到，继续通过_ _proto_ _往上级对象上找，一直找不到Object.prototype。。。如果还没有找到就报undefined
		
	

	所有的类都是个函数


	Object是个基类
	object.prototype上没有_ _proto_ _属性么

	

	原型继承是js特有的一种机制


	批量设置公有的属性，prototype不再指向浏览器默认开辟的堆内存，prototype则指向重新开辟的堆内存
	浏览器在空闲的时候，会把默认开辟的堆内存